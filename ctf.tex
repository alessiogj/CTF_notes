\documentclass[oneside,a4paper,11pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{svg}
\usepackage[italian]{babel}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{titling}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{listings}
\usepackage[DIV=12,BCOR=2mm,headinclude=true,footinclude=false]{typearea}
\usepackage{color, colortbl,xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{tcolorbox}
\usepackage{chngcntr}
\usepackage{diagbox}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{cancel}
\usepackage{forest}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{makecell}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}}
\pagestyle{fancy}
\fancyhf{}% Clear header/footer
\fancyhead[L]{\nouppercase\leftmark}
\fancyhead[R]{\thepage}
\usetikzlibrary{positioning,shapes.geometric,arrows.meta,matrix,automata,decorations.pathmorphing,patterns,decorations.pathreplacing,shapes.multipart,calc,snakes}
\usetikzlibrary{arrows.meta, backgrounds, chains, positioning, shapes.geometric, shapes.multipart}
\tcbuselibrary{skins}
\counterwithin{figure}{section}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% Configurazione per Python
\lstdefinestyle{pythonStyle}{
    backgroundcolor=\color{white},
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{mygreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{mygray},
    numbers=left,
    rulecolor=\color{black},
    showstringspaces=false,
    stringstyle=\color{mymauve},
    tabsize=4,
    language=Python
}

% Configurazione per Bash
\lstdefinestyle{bashStyle}{
    backgroundcolor=\color{white},
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{mygreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{mygray},
    numbers=left,
    rulecolor=\color{black},
    showstringspaces=false,
    stringstyle=\color{mymauve},
    tabsize=4,
    language=Bash
}
%Nuovi comandi
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\newcommand\prodG{\stackrel{\mathclap{\normalfont\mbox{\tiny{G}}}}{\Longrightarrow}}
%asmthm
\newlength{\marginlabelsep}\setlength{\marginlabelsep}{0.5em}
\newtheoremstyle{italicstyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\itshape} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\newtheoremstyle{normStyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\normalfont} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\theoremstyle{italicstyle}
\newtheorem{corollary}{Corollario}[section]
\newtheorem{notazione}{Notazione}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definizione}{Definizione}[section]
\newtheorem{nota}{Nota}[section]
\newtheorem{exercise}{Esercizio}[section]
\theoremstyle{normStyle}
\newtheorem{exmp}{Esempio}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{proposizione}{Proposizione}[section]
\tcbuselibrary{listings,skins}
\newtcblisting{mylisting}[2][]{
    arc=0pt, outer arc=0pt,
    listing only, 
    title=#2,
    #1,
    listing options= {escapechar=|}
}
\newcommand{\myboxedtext}[2][rectangle,draw]{%
    \tikz[baseline=-0.6ex] \node [#1]{#2};}%
%%======================================================================
\title{Capture the Flag Manual}
\author{
\textit{Alessio Gjergji}\\
\textit{Nicolò Piccoli} \\
\textit{Davide Rossignolo} \\
\textit{Author 4} \\
\textit{Author 5}}
\date{}
\begin{document}
\maketitle
\tableofcontents
\chapter{Software Security OlyCyber}
\section{Introduzione}
I numeri interi, in questo caso int32, possono essere rappresentati in due maniera, Big-Endian(cifra significativa a sinistra) e Little-Endian(cifra significativa a destra).
\section{Assembly x86\_64}
Ogni istruzione assembly ha degli operandi(registri) e un'operazione.\\
La notazione per architetture intel è del tipo \textless op\textgreater\textless destinazione\textgreater\textless sorgente\textgreater, i registri hanno la seguente struttura:
AH,AL -> 8 bit, AX -> 16 bit, EAX -> 32 bit, RAX -> 64 bit.\\
Tra le operazioni di base che troviamo ci sono: \\
MOV \textless dst\textgreater\textless src\textgreater\\
PUSH \textless src\textgreater or POP\textless src\textgreater\\
ADD or SUB \textless dst\textgreater\textless src\textgreater\\
CALL \textless pc\textgreater or RET\\
Tra i salti condizionali invece abbiamo:
CMP \textless opn1\textgreater\textless opn2\textgreater -> confronta due valori e imposta delle flag\\
J \textless condizione\textgreater\textless pc\textgreater -> salta a PC se le flag soddisfano la condizione\\
\section{Buffer Overflow}
Consideriamo di aver dichiarato in c un'istruzione del tipo "char name[100];", cosa succede se l'utente ha un nome che supera i 100 caratteri?.
Può succedere che con scanf() andiamo a scrivere caratteri oltre la fine di name, andando a sovrascrivere la memoria che lo segue, generando quindi un buffer overflow che va a corrompere la memoria, ossia scriviamo dati in posizioni che il programmatore non aveva previsto fossero modificate.\\
Se corrompiamo abbastanza bene la memoria possiamo addirittura prendere il controllo del processo(arbitrary code execution).
\subsection{Accessi out of bound}
Se abbiamo una struct che dichiara un int a[2] e un int b[3], nel momento in cui scrivo in a[2] o in b[0] non cambia niente, sono equivalenti.
\section{Reverse Engineering}
\subsection{Binary}
Gli eseguibili nativi sono file che contengono codice macchina eseguibile dal processore, contengono anche informazioni usate dal sistema operativo per caricarlo in memoria.\\
Il formato \textbf{elf} è flessibile e serve a rappresentare i file binari, in linux è usato per rappresentare eseguibili e librerie condivise, ad alto livello invece risulta come un insieme di strutture che descrivono come caricare in memoria i dati salvati nello stessso file.\\
Per analizzare file ELF abbiamo alcuni strumenti tra cui:
\begin{itemize}
  \item \textbf{readelf}: stampa le informazioni contenute nei file elf
  \item textbf{nm}: stampa tutti i simboli contenuti nel file elf
\item textbf{objdump}: stampa le informazioni contenute nel file oggetto, è più specifico rispetto a readelf
\item textbf{lld}: stampa gli oggetti condivisi necessari all'esecuzione del programma
\item textbf{lief}: libreria python per analizzare e modificare file elf.
\end{itemize}

\subsection{Memoria a basso livello}
Se vogliamo considerare un'astrazione della memoria troviamo vari livelli:
 \begin{itemize}
  \item \textbf{dati tipati}: byte interpretati
  \item linguaggi di programmazione
\item textbf{memoria virtuale}: sequenza di byte indirizzabili, spazio indipendente per processo, solo alcune aree mappate(con la fisica)
\item sistema operativo
\item textbf{memoria fisica}: sequenza di byte indirizzabili
\end{itemize}

\subsection{Spazio virtuale linux user space}

 \begin{itemize}
  \item Text
  \item Data -> dati globali inizializzati
\item BSS -> dati globali azzerati
\item Heap -> allocazioni dinamiche
\item Librerie -> binari librerie dinamiche
\item Stack -> var locali, record di attivazione
\end{itemize}

\subsection{metodologie di base di reverse}
Tool per analisi statica: Ghidra, IDA, Binary Ninja, Radare2 -> analizzano qualsiasi binario in input\\
\begin{itemize}
\item JADX: reverse bytecode java
\item dnSpy, ILSpy: reverse bytecode .NET
\item uncompyle6/unpyc: reverse bytecode python
\item Iuadec: reverse bytecode LUA.
\end{itemize}
Tool per analisi dinamica:
\begin{itemize}
\item gdb: da usare con GEF o PWNDBG
\item radare2 integra features comode per il reversing
\item rr timeless debugging
\item frida inietta codice js in qualsiasi punto del programma
\item ida debugger debugger gui disponibile free.
\end{itemize}

\chapter{Sw Sec Lab Univr}
\section{Elf File}
È il file standard per gli eseguibili Unix, Elf sta per Executable and Linkable Format, è essenzialmente un file binario che continene varie informazioni tra cui:
\begin{itemize}
	\item \textbf{header}: descrive il contenuto del file per l'esecuzione
	\item \textbf{Pht(program header table)}: da informazioni su come si crea l'immagine del processo
	\item \textbf{Sequenza di sezioni}: contengono ciò che serve per il linking
	\item \textbf{Section header table}: descrizione delle sezioni precedenti 
\end{itemize}
Per windows l'equivalente è PE, per mac Mach-O
\section{Memoria}
\subsection{Storage Size}
WORD = 2 BYTES, DWORD = 4 BYTES, QUADWORD = 8 BYTES.
La cifra più significativa è a sinistra, quella meno è a destra.
\subsection{Hexadecimal}
Si usa come forma compatta dei numeri binari, si va da 0 a 9 e da A a F.\\
Ogni digit in hex rappresenta 4 bits, quindi 2 digit un bytes, in C sono scritti come 0X FA 1D .... .
\subsection{Registri x86\_32}
Ha registri general purpose a 32 bit.\\
Sono strutturati nella seguente maniera: AH,AL 8 bit ciascuno, AX 16 bit, EAX 32 bit.\\
EAX è storicamente usato come accumulatore, ECX come counter, inoltre ci sono ESP(stack pointer) e EBP(base pointer).\\
Se passiamo a x86\_64 si aggiungono i registri a 64 bit che si nominano del tipo: RAX.
\subsection{x86 Memory managment}
La memoria è semplicemente una sequenza di bytes, ognuno con un indirizzo unico, i compilatori potrebbero introdurre padding per cambiare l'ordine dei dati per ottimizzare, per questo motivo ci torna comodo vederla come una matrice di tot righe con n bytes(n=processor word), se sono a 64 bit n=8.\\
Un indirizzo è una locazione in memoria, un \textbf{puntatore} è un oggetto mantiene un indirizzo.
I bytes possono essere ordinati in memoria in due maniere:
\begin{itemize}
\item \textbf{BigEndian}: il bytes meno significativo ha indirizzo più alto
\item \textbf{LittleEndian}: il bytes meno significativo ha indirizzo più basso
\end{itemize}
\section{intel x86 instruction set}
La notazione per architetture intel è del tipo \textless op\textgreater\textless destinazione\textgreater\textless sorgente\textgreater\\
Vediamo ora alcune istruzioni:
\begin{itemize}
\item mov: muove dati da un src a un registro dst
\item push: mette l'operando sullo stack
\item pop: rimuove l'operando dallo stack
\item lea: carica ciò che c'è all'indirizzo [] in dst
\item add: fa la somma e salva in op1
\item sub: fa la differenza e salva in op1
\item inc: incrementa di 1
\item and/or/xor: fa l'operazione e salva in op1
\item jump: salto non condizionale a label
\item cmp: compara contenuto di op1 con op2
\item je/jne/jz/jg/jge/jl/jle: in base a cmp fa salto condionale 
\item call: usato per chiamare funzioni
\item ret: implementa il ritorno da funzione
\end{itemize}
Per quanto riguarda lo stack, questo è formato da degli stack frames, uno per ogni funzione chiamata, \textbf{stack pointer} punta all'ultimo elemento nello stack(il primo inserito).\\
Per quanto riguarda ogni singolo frame, abbiamo che \textbf{base pointer(frame pointer)} punta l'indirizzo dal quale partono le variabili locali.
\section{Debugging con GDB}
Posso usare gdb in varie maniere:
\begin{itemize}
\item gdb \textgreater program \textless
\item gdb \textgreater program \textless \textgreater pid \textless 
\item gdb  -p \textgreater pid \textless
\end{itemize}

\subsection{Comandi di GDB}
\begin{itemize}
\item run: fa partire il programma in gdb
\item set args: imposta gli argomenti del programma
\item show args: mostra gli argomenti del programma
\item help: comandi disponibili
\item break: mette breakpoint alla prossima istruzione
\item break location: mette un breakpoint alla locazione location(preceduta da *)
\item break [location] if \textgreater condition \textless: mette un breakpoint data una condizione
\item continue(c): va al prossimo breakpoint(se esiste)
\item nexti(ni): esegue solo un'istruzione
\item frame [\textgreater selection \textless]: stampa una descrizione dello stack frame selezionato
\item info frame [\textgreater selection \textless]: stampa una descrizione più informativa rispetto a frame
\item disas: disassembla una funzione
\item print(p): stampa il contenuto di un indirizzo o registro(*0x092a3e or \$eax)  
\item x: non ho ben capito
\item call: chiama una funzione 
\item set: modifica il valore di una locazione di memoria o di un registro

\end{itemize}


\chapter{Comandi terminale}
\section{Introduzione}
Durante una ctf potremmo trovarci di fronte ad alcune challenge in cui è necessario l'utilizzo di vari comandi della shell per recuperare la flag richiesta e quindi passare alla challenge successiva.
Di seguito vedremo alcuni comandi della shell per sistemi UNIX o macOS che possono tornare utili.

\section{Comandi di base}
Se si conosce un comando ma non si sa come utilizzarlo è bene consultare il manuale scrivendo sul terminale \textbf{man} $\langle command \rangle$. Se non è presente la pagina del manuale provare a specificare il flag \textbf{--help}. 

\section{Operazioni sulle directory}
\subsection{cd}
Per navigare attraverso il filesystem utilizziamo il comando \textbf{cd dir}.
\begin{itemize}
    \item \textbf{cd esempio} (ci spostiamo nella cartella \textit{esempio})
    \item \textbf{cd Dekstop/esempio} (ci spostiamo nella cartella \textit{esempio} identificata dal suo path)
    \item \textbf{cd ..} (ci permette di spostarci nella cartella superiore)
    \item \textbf{cd $\sim$} (ci spostiamo nella home directory)
    \item \textbf{cd /} (ci spostiamo nella root directory)
\end{itemize}
Per creare una cartella utilizziamo il comando \textbf{mk dir}, se invece vogliamo vedere la cartella corrente utlizziamo il comando \textbf{pwd}.

\subsection{ls}
Se vogliamo vedere i file all'interno di una cartella utilizziamo il comando \textbf{ls}.
\begin{itemize}
    \item \textbf{ls} (mostra i file nella cartella corrente)
    \item \textbf{ls Desktop/esempio} (mostra i file all'interno della cartella \textit{esempio} identificata dal path)
\end{itemize}
Tra le opzioni del comando \textbf{ls} possiamo trovare:
\begin{itemize}
    \item \textbf{-a} (mostra tutti i file, inclusi quelli nascosti)
    \item \textbf{-r} (inverte l'ordine della lista)
    \item \textbf{-t} (ordina in base all'ultimo modificato)
    \item \textbf{-S} (ordina per dimensione del file)
\end{itemize}

\section{Operazioni sui file}
\subsection{touch}
Per creare un file utilizzare il comando \textbf{touch file}.

\subsection{cat}
Il comando \textbf{cat} permette di concatenare file e stampare il loro contenuto sullo standard output.
\begin{itemize}
    \item \textbf{cat file} (stampa il contenuto del file, se vengono specificati più file li concatena e stampa il contenuto, e.g. cat file file2)
    \item \textbf{cat $<$ -file} (permette di stampare il contenuto di un file con il nome che inizia con un dash)
    \item \textbf{cat $"nome file con spazi"$} (permette di stampare il contenuto di un file che contiene spazi nel nome)
    \item \textbf{cat .file} (stampa il contenuto del file nascosto)
\end{itemize}

\subsection{cp, mv, rm, file}
\begin{itemize}
    \item \textbf{cp file file2} (copia file in file2)
    \item \textbf{mv file file2} (rinomino file in file2)
    \item \textbf{rm file} (elimino file)
        \begin{itemize}
            \item \textbf{rm -r} (rimuovo le directory e i loro contenuti)
            \item \textbf{rm -d} (rimuovo direcotry vuote)
        \end{itemize}
    \item \textbf{file file1} (ritorna il tipo di file1)
\end{itemize}

\subsection{head, tail}
\begin{itemize}
    \item \textbf{head file1} (ritorna le prime 10 linee di file1)
    \item \textbf{tail file1} (ritorna le ultime 10 linee di file1)
\end{itemize}

\subsection{strings}
Il comando \textbf{strings} stampa una sequenza di stringhe leggibili all'interno di un file.
\begin{itemize}
    \item \textbf{strings file}
    \begin{itemize}
        \item con il flag \textbf{-n number-of-lines} (specifichiamo la lunghezza minima delle stringhe)
        \item con il flag \textbf{-e encoding} (specifichiamo la codifica)
        \item con il flag \textbf{-w} (includiamo gli spazi bianchi)
        \item con il flag \textbf{-s} (il separatore per l'output)
    \end{itemize}
\end{itemize}

\section{Ricerca}
\subsection{sort, unique}
Il comando \textbf{sort file} permette di ordinare le linee all'interno di un file, il comando \textbf{unique -u} permette di mostrare le linee uniche non duplicate, questi due comandi possono essere comodi da usare in combinazione attraverso l'utilizzo di una pipe: \textbf{sort nomefile | unique -u}.

\subsection{grep}
Il comando \textbf{grep pattern files} permette di cercare un determinato pattern in ogni file, i pattern andrebbero specificati sempre compresi tra doppi apici.

\begin{itemize}
    \item \textbf{grep -i } (ricerca case-insensitive)
    \item \textbf{grep -r } (ricerca ricorsiva)
    \item \textbf{grep -v } (ricerca invertita)
    \item \textbf{grep -o } (mostra solo la parte di file che ha matchato il pattern)
\end{itemize}

\subsection{find}
Il comando \textbf{find} permette di cercare dei file all'interno del filesystem.

\begin{itemize}
    \item \textbf{find /percorso -name $"filename"$} (ricerca per nome)
    \item \textbf{find /percorso -name $"*.txt"$} (ricerca per estensione)
    \item \textbf{find /percorso -type f -size +1M} (ricerca per dimensione)
    \item \textbf{find /percorso -user utente -group gruppo} (ricerca per proprietario e gruppo)
    \item \textbf{find /percorso -mtime -7} (ricerca per data di modifica)
\end{itemize}

\section{Connessioni ssh o tcp}
Connessione ad una risorsa in ssh:

\begin{itemize}
    \item \textbf{ssh -p numero-porta utente@indirizzo-del-server}
\end{itemize}

Connessione tramite tcp:

\begin{itemize}
    \item \textbf{nc host port}
\end{itemize}

\section{Gestione dei processi}
\begin{itemize}
    \item \textbf{ps} (mostra uno snapshot dei processi)
    \item \textbf{top} (mostra i processi real-time)\item \textbf{}
    \item \textbf{kill pid} (termina un processo con il pid=pid)
    \item \textbf{pkill name} (termina un processo col nome=name)
    \item \textbf{killall name} (termina tutti i processi con il nome che inizia per name)
\end{itemize}

\input{cryptography.tex}
\end{document}
