\documentclass[oneside,a4paper,11pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{svg}
\usepackage[italian]{babel}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{titling}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{listings}
\usepackage[DIV=12,BCOR=2mm,headinclude=true,footinclude=false]{typearea}
\usepackage{color, colortbl,xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{tcolorbox}
\usepackage{chngcntr}
\usepackage{diagbox}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{cancel}
\usepackage{forest}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{makecell}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}}
\pagestyle{fancy}
\fancyhf{}% Clear header/footer
\fancyhead[L]{\nouppercase\leftmark}
\fancyhead[R]{\thepage}
\usetikzlibrary{positioning,shapes.geometric,arrows.meta,matrix,automata,decorations.pathmorphing,patterns,decorations.pathreplacing,shapes.multipart,calc,snakes}
\usetikzlibrary{arrows.meta, backgrounds, chains, positioning, shapes.geometric, shapes.multipart}
\tcbuselibrary{skins}
\counterwithin{figure}{section}
%Nuovi comandi
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\newcommand\prodG{\stackrel{\mathclap{\normalfont\mbox{\tiny{G}}}}{\Longrightarrow}}
%asmthm
\newlength{\marginlabelsep}\setlength{\marginlabelsep}{0.5em}
\newtheoremstyle{italicstyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\itshape} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\newtheoremstyle{normStyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\normalfont} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\theoremstyle{italicstyle}
\newtheorem{corollary}{Corollario}[section]
\newtheorem{notazione}{Notazione}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definizione}{Definizione}[section]
\newtheorem{nota}{Nota}[section]
\newtheorem{exercise}{Esercizio}[section]
\theoremstyle{normStyle}
\newtheorem{exmp}{Esempio}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{proposizione}{Proposizione}[section]
\tcbuselibrary{listings,skins}
\newtcblisting{mylisting}[2][]{
    arc=0pt, outer arc=0pt,
    listing only, 
    title=#2,
    #1,
    listing options= {escapechar=|}
}
\newcommand{\myboxedtext}[2][rectangle,draw]{%
    \tikz[baseline=-0.6ex] \node [#1]{#2};}%
%%======================================================================
\title{Capture the Flag Manual}
\author{\textit{Alessio Gjergji}}\\
\textit{\textit{Nicolò Piccoli}} \\
\textit{\textit{Davide Rossignolo}} \\
\textit{Author 4} \\
\textit{Author 5}}
\date{}
\begin{document}
\maketitle
\tableofcontents
\chapter{Introduzione}

\chapter{Software Security OlyCyber}
\section{Introduzione}
I numeri interi, in questo caso int32, possono essere rappresentati in due maniera, Big-Endian(cifra significativa a sinistra) e Little-Endian(cifra significativa a destra).
\section{Assembly x86\_64}
Ogni istruzione assembly ha degli operandi(registri) e un'operazione.\\
La notazione per architetture intel è del tipo \textless op\textgreater\textless destinazione\textgreater\textless sorgente\textgreater, i registri hanno la seguente struttura:
AH,AL -> 8 bit, AX -> 16 bit, EAX -> 32 bit, RAX -> 64 bit.\\
Tra le operazioni di base che troviamo ci sono: \\
MOV \textless dst\textgreater\textless src\textgreater\\
PUSH \textless src\textgreater or POP\textless src\textgreater\\
ADD or SUB \textless dst\textgreater\textless src\textgreater\\
CALL \textless pc\textgreater or RET\\
Tra i salti condizionali invece abbiamo:
CMP \textless opn1\textgreater\textless opn2\textgreater -> confronta due valori e imposta delle flag\\
J \textless condizione\textgreater\textless pc\textgreater -> salta a PC se le flag soddisfano la condizione\\
\section{Buffer Overflow}
Consideriamo di aver dichiarato in c un'istruzione del tipo "char name[100];", cosa succede se l'utente ha un nome che supera i 100 caratteri?.
Può succedere che con scanf() andiamo a scrivere caratteri oltre la fine di name, andando a sovrascrivere la memoria che lo segue, generando quindi un buffer overflow che va a corrompere la memoria, ossia scriviamo dati in posizioni che il programmatore non aveva previsto fossero modificate.\\
Se corrompiamo abbastanza bene la memoria possiamo addirittura prendere il controllo del processo(arbitrary code execution).
\subsection{Accessi out of bound}
Se abbiamo una struct che dichiara un int a[2] e un int b[3], nel momento in cui scrivo in a[2] o in b[0] non cambia niente, sono equivalenti.
\section{Reverse Engineering}
\subsection{Binary}
Gli eseguibili nativi sono file che contengono codice macchina eseguibile dal processore, contengono anche informazioni usate dal sistema operativo per caricarlo in memoria.\\
Il formato \textbf{elf} è flessibile e serve a rappresentare i file binari, in linux è usato per rappresentare eseguibili e librerie condivise, ad alto livello invece risulta come un insieme di strutture che descrivono come caricare in memoria i dati salvati nello stessso file.\\
Per analizzare file ELF abbiamo alcuni strumenti tra cui:
\begin{itemize}
  \item \textbf{readelf}: stampa le informazioni contenute nei file elf
  \item textbf{nm}: stampa tutti i simboli contenuti nel file elf
\item textbf{objdump}: stampa le informazioni contenute nel file oggetto, è più specifico rispetto a readelf
\item textbf{lld}: stampa gli oggetti condivisi necessari all'esecuzione del programma
\item textbf{lief}: libreria python per analizzare e modificare file elf.
\end{itemize}

\subsection{Memoria a basso livello}
Se vogliamo considerare un'astrazione della memoria troviamo vari livelli:
 \begin{itemize}
  \item \textbf{dati tipati}: byte interpretati
  \item linguaggi di programmazione
\item textbf{memoria virtuale}: sequenza di byte indirizzabili, spazio indipendente per processo, solo alcune aree mappate(con la fisica)
\item sistema operativo
\item textbf{memoria fisica}: sequenza di byte indirizzabili
\end{itemize}

\subsection{Spazio virtuale linux user space}

 \begin{itemize}
  \item Text
  \item Data -> dati globali inizializzati
\item BSS -> dati globali azzerati
\item Heap -> allocazioni dinamiche
\item Librerie -> binari librerie dinamiche
\item Stack -> var locali, record di attivazione
\end{itemize}

\subsection{metodologie di base di reverse}
Tool per analisi statica: Ghidra, IDA, Binary Ninja, Radare2 -> analizzano qualsiasi binario in input\\
\begin{itemize}
\item JADX: reverse bytecode java
\item dnSpy, ILSpy: reverse bytecode .NET
\item uncompyle6/unpyc: reverse bytecode python
\item Iuadec: reverse bytecode LUA.
\end{itemize}
Tool per analisi dinamica:
\begin{itemize}
\item gdb: da usare con GEF o PWNDBG
\item radare2 integra features comode per il reversing
\item rr timeless debugging
\item frida inietta codice js in qualsiasi punto del programma
\item ida debugger debugger gui disponibile free.
\end{itemize}

\chapter{Sw Sec Lab Univr}
\section{Elf File}
È il file standard per gli eseguibili Unix, Elf sta per Executable and Linkable Format, è essenzialmente un file binario che continene varie informazioni tra cui:
\begin{itemize}
	\item \texbf{header}: descrive il contenuto del file per l'esecuzione
	\item \texbf{Pht(program header table)}: da informazioni su come si crea l'immagine del processo
	\item \texbf{Sequenza di sezioni}: contengono ciò che serve per il linking
	\item \texbf{Section header table}: descrizione delle sezioni precedenti 
\end{itemize}
Per windows l'equivalente è PE, per mac Mach-O
\section{Memoria}
\subsection{Storage Size}
WORD = 2 BYTES, DWORD = 4 BYTES, QUADWORD = 8 BYTES.
La cifra più significativa è a sinistra, quella meno è a destra.
\subsection{Hexadecimal}
Si usa come forma compatta dei numeri binari, si va da 0 a 9 e da A a F.\\
Ogni digit in hex rappresenta 4 bits, quindi 2 digit un bytes, in C sono scritti come 0X FA 1D .... .
\subsection{Registri x86_32}
Ha registri general purpose a 32 bit.\\
Sono strutturati nella seguente maniera: AH,AL 8 bit ciascuno, AX 16 bit, EAX 32 bit.\\
EAX è storicamente usato come accumulatore, ECX come counter, inoltre ci sono ESP(stack pointer) e EBP(base pointer).\\
Se passiamo a x86_64 si aggiungono i registri a 64 bit che si nominano del tipo: RAX.
\subsection{x86 Memory managment}
La memoria è semplicemente una sequenza di bytes, ognuno con un indirizzo unico, i compilatori potrebbero introdurre padding per cambiare l'ordine dei dati per ottimizzare, per questo motivo ci torna comodo vederla come una matrice di tot righe con n bytes(n=processor word), se sono a 64 bit n=8.\\
Un indirizzo è una locazione in memoria, un \textbf{puntatore} è un oggetto mantiene un indirizzo.
I bytes possono essere ordinati in memoria in due maniere:
\begin{itemize}
\item \texbf{BigEndian}: il bytes meno significativo ha indirizzo più alto
\item \texbf{LittleEndian}: il bytes meno significativo ha indirizzo più basso
\end{itemize}  
\end{document}
