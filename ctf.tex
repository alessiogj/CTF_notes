\documentclass[oneside,a4paper,11pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{svg}
\usepackage[italian]{babel}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{titling}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{listings}
\usepackage[DIV=12,BCOR=2mm,headinclude=true,footinclude=false]{typearea}
\usepackage{color, colortbl,xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{tcolorbox}
\usepackage{chngcntr}
\usepackage{diagbox}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{cancel}
\usepackage{forest}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{makecell}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}}
\pagestyle{fancy}
\fancyhf{}% Clear header/footer
\fancyhead[L]{\nouppercase\leftmark}
\fancyhead[R]{\thepage}
\usetikzlibrary{positioning,shapes.geometric,arrows.meta,matrix,automata,decorations.pathmorphing,patterns,decorations.pathreplacing,shapes.multipart,calc,snakes}
\usetikzlibrary{arrows.meta, backgrounds, chains, positioning, shapes.geometric, shapes.multipart}
\tcbuselibrary{skins}
\counterwithin{figure}{section}
%Nuovi comandi
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\newcommand\prodG{\stackrel{\mathclap{\normalfont\mbox{\tiny{G}}}}{\Longrightarrow}}
%asmthm
\newlength{\marginlabelsep}\setlength{\marginlabelsep}{0.5em}
\newtheoremstyle{italicstyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\itshape} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\newtheoremstyle{normStyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\normalfont} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\theoremstyle{italicstyle}
\newtheorem{corollary}{Corollario}[section]
\newtheorem{notazione}{Notazione}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definizione}{Definizione}[section]
\newtheorem{nota}{Nota}[section]
\newtheorem{exercise}{Esercizio}[section]
\theoremstyle{normStyle}
\newtheorem{exmp}{Esempio}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{proposizione}{Proposizione}[section]
\tcbuselibrary{listings,skins}
\newtcblisting{mylisting}[2][]{
    arc=0pt, outer arc=0pt,
    listing only, 
    title=#2,
    #1,
    listing options= {escapechar=|}
}
\newcommand{\myboxedtext}[2][rectangle,draw]{%
    \tikz[baseline=-0.6ex] \node [#1]{#2};}%
%%======================================================================
\title{Capture the Flag Manual}
\author{
\textit{Alessio Gjergji}\\
\textit{Nicolò Piccoli} \\
\textit{Davide Rossignolo} \\
\textit{Author 4} \\
\textit{Author 5}}
\date{}
\begin{document}
\maketitle
\tableofcontents
\chapter{Software Security OlyCyber}
\section{Introduzione}
I numeri interi, in questo caso int32, possono essere rappresentati in due maniera, Big-Endian(cifra significativa a sinistra) e Little-Endian(cifra significativa a destra).
\section{Assembly x86\_64}
Ogni istruzione assembly ha degli operandi(registri) e un'operazione.\\
La notazione per architetture intel è del tipo \textless op\textgreater\textless destinazione\textgreater\textless sorgente\textgreater, i registri hanno la seguente struttura:
AH,AL -> 8 bit, AX -> 16 bit, EAX -> 32 bit, RAX -> 64 bit.\\
Tra le operazioni di base che troviamo ci sono: \\
MOV \textless dst\textgreater\textless src\textgreater\\
PUSH \textless src\textgreater or POP\textless src\textgreater\\
ADD or SUB \textless dst\textgreater\textless src\textgreater\\
CALL \textless pc\textgreater or RET\\
Tra i salti condizionali invece abbiamo:
CMP \textless opn1\textgreater\textless opn2\textgreater -> confronta due valori e imposta delle flag\\
J \textless condizione\textgreater\textless pc\textgreater -> salta a PC se le flag soddisfano la condizione\\
\section{Buffer Overflow}
Consideriamo di aver dichiarato in c un'istruzione del tipo "char name[100];", cosa succede se l'utente ha un nome che supera i 100 caratteri?.
Può succedere che con scanf() andiamo a scrivere caratteri oltre la fine di name, andando a sovrascrivere la memoria che lo segue, generando quindi un buffer overflow che va a corrompere la memoria, ossia scriviamo dati in posizioni che il programmatore non aveva previsto fossero modificate.\\
Se corrompiamo abbastanza bene la memoria possiamo addirittura prendere il controllo del processo(arbitrary code execution).
\subsection{Accessi out of bound}
Se abbiamo una struct che dichiara un int a[2] e un int b[3], nel momento in cui scrivo in a[2] o in b[0] non cambia niente, sono equivalenti.
\section{Reverse Engineering}
\subsection{Binary}
Gli eseguibili nativi sono file che contengono codice macchina eseguibile dal processore, contengono anche informazioni usate dal sistema operativo per caricarlo in memoria.\\
Il formato \textbf{elf} è flessibile e serve a rappresentare i file binari, in linux è usato per rappresentare eseguibili e librerie condivise, ad alto livello invece risulta come un insieme di strutture che descrivono come caricare in memoria i dati salvati nello stessso file.\\
Per analizzare file ELF abbiamo alcuni strumenti tra cui:
\begin{itemize}
  \item \textbf{readelf}: stampa le informazioni contenute nei file elf
  \item \textbf{nm}: stampa tutti i simboli contenuti nel file elf
\item \textbf{objdump}: stampa le informazioni contenute nel file oggetto, è più specifico rispetto a readelf
\item \textbf{lld}: stampa gli oggetti condivisi necessari all'esecuzione del programma
\item \textbf{lief}: libreria python per analizzare e modificare file elf.
\end{itemize}

\subsection{Memoria a basso livello}
Se vogliamo considerare un'astrazione della memoria troviamo vari livelli:
 \begin{itemize}
  \item \textbf{dati tipati}: byte interpretati
  \item linguaggi di programmazione
\item \textbf{memoria virtuale}: sequenza di byte indirizzabili, spazio indipendente per processo, solo alcune aree mappate(con la fisica)
\item sistema operativo
\item \textbf{memoria fisica}: sequenza di byte indirizzabili
\end{itemize}

\subsection{Spazio virtuale linux user space}

 \begin{itemize}
  \item Text
  \item Data $\rightarrow$ dati globali inizializzati
\item BSS $\rightarrow$ dati globali azzerati
\item Heap $\rightarrow$ allocazioni dinamiche
\item Librerie $\rightarrow$ binari librerie dinamiche
\item Stack $\rightarrow$ var locali, record di attivazione
\end{itemize}

\subsection{metodologie di base di reverse}
Tool per analisi statica: Ghidra, IDA, Binary Ninja, Radare2 -> analizzano qualsiasi binario in input\\
\begin{itemize}
\item JADX: reverse bytecode java
\item dnSpy, ILSpy: reverse bytecode .NET
\item uncompyle6/unpyc: reverse bytecode python
\item Iuadec: reverse bytecode LUA.
\end{itemize}
Tool per analisi dinamica:
\begin{itemize}
\item gdb: da usare con GEF o PWNDBG
\item radare2 integra features comode per il reversing
\item rr timeless debugging
\item frida inietta codice js in qualsiasi punto del programma
\item ida debugger debugger gui disponibile free.
\end{itemize}

\chapter{Sw Sec Lab Univr}
\section{Elf File}
È il file standard per gli eseguibili Unix, Elf sta per Executable and Linkable Format, è essenzialmente un file binario che continene varie informazioni tra cui:
\begin{itemize}
	\item \textbf{header}: descrive il contenuto del file per l'esecuzione
	\item \textbf{Pht(program header table)}: da informazioni su come si crea l'immagine del processo
	\item \textbf{Sequenza di sezioni}: contengono ciò che serve per il linking
	\item \textbf{Section header table}: descrizione delle sezioni precedenti 
\end{itemize}
Per windows l'equivalente è PE, per mac Mach-O
\section{Memoria}
\subsection{Storage Size}
WORD = 2 BYTES, DWORD = 4 BYTES, QUADWORD = 8 BYTES.
La cifra più significativa è a sinistra, quella meno è a destra.
\subsection{Hexadecimal}
Si usa come forma compatta dei numeri binari, si va da 0 a 9 e da A a F.\\
Ogni digit in hex rappresenta 4 bits, quindi 2 digit un bytes, in C sono scritti come 0X FA 1D .... .
\subsection{Registri x86\_32}
Ha registri general purpose a 32 bit.\\
Sono strutturati nella seguente maniera: AH,AL 8 bit ciascuno, AX 16 bit, EAX 32 bit.\\
EAX è storicamente usato come accumulatore, ECX come counter, inoltre ci sono ESP(stack pointer) e EBP(base pointer).\\
Se passiamo a x86\_64 si aggiungono i registri a 64 bit che si nominano del tipo: RAX.
\subsection{x86 Memory managment}
La memoria è semplicemente una sequenza di bytes, ognuno con un indirizzo unico, i compilatori potrebbero introdurre padding per cambiare l'ordine dei dati per ottimizzare, per questo motivo ci torna comodo vederla come una matrice di tot righe con n bytes(n=processor word), se sono a 64 bit n=8.\\
Un indirizzo è una locazione in memoria, un \textbf{puntatore} è un oggetto mantiene un indirizzo.
I bytes possono essere ordinati in memoria in due maniere:
\begin{itemize}
\item \textbf{BigEndian}: il bytes meno significativo ha indirizzo più alto
\item \textbf{LittleEndian}: il bytes meno significativo ha indirizzo più basso
\end{itemize}
\section{intel x86 instruction set}
La notazione per architetture intel è del tipo \textless op\textgreater\textless destinazione\textgreater\textless sorgente\textgreater\\
Vediamo ora alcune istruzioni:
\begin{itemize}
\item mov: muove dati da un src a un registro dst
\item push: mette l'operando sullo stack
\item pop: rimuove l'operando dallo stack
\item lea: carica ciò che c'è all'indirizzo [] in dst
\item add: fa la somma e salva in op1
\item sub: fa la differenza e salva in op1
\item inc: incrementa di 1
\item and/or/xor: fa l'operazione e salva in op1
\item jump: salto non condizionale a label
\item cmp: compara contenuto di op1 con op2
\item je/jne/jz/jg/jge/jl/jle: in base a cmp fa salto condionale 
\item call: usato per chiamare funzioni
\item ret: implementa il ritorno da funzione
\end{itemize}
Per quanto riguarda lo stack, questo è formato da degli stack frames, uno per ogni funzione chiamata, \textbf{stack pointer} punta all'ultimo elemento nello stack(il primo inserito).\\
Per quanto riguarda ogni singolo frame, abbiamo che \textbf{base pointer(frame pointer)} punta l'indirizzo dal quale partono le variabili locali.
\section{Debugging con GDB}
Posso usare gdb in varie maniere:
\begin{itemize}
\item gdb \textgreater program \textless
\item gdb \textgreater program \textless \textgreater pid \textless 
\item gdb  -p \textgreater pid \textless
\end{itemize}

\subsection{Comandi di GDB}
\begin{itemize}
\item run: fa partire il programma in gdb
\item set args: imposta gli argomenti del programma
\item show args: mostra gli argomenti del programma
\item help: comandi disponibili
\item break: mette breakpoint alla prossima istruzione
\item break location: mette un breakpoint alla locazione location(preceduta da *)
\item break [location] if \textgreater condition \textless: mette un breakpoint data una condizione
\item continue(c): va al prossimo breakpoint(se esiste)
\item nexti(ni): esegue solo un'istruzione
\item frame [\textgreater selection \textless]: stampa una descrizione dello stack frame selezionato
\item info frame [\textgreater selection \textless]: stampa una descrizione più informativa rispetto a frame
\item disas: disassembla una funzione
\item print(p): stampa il contenuto di un indirizzo o registro(*0x092a3e or \$eax)  
\item x: non ho ben capito
\item call: chiama una funzione 
\item set: modifica il valore di una locazione di memoria o di un registro

\end{itemize}

\chapter{Strumenti di reverse engineering}

\textit{Scritto da Seekbytes}

Questo capitolo introduce il funzionamento tipico di strumenti di reverse engineering che analizzano binari per architetture general-purpose reali utilizzando linguaggi compilati. Salteremo tutto ciò che riguarda il reverse engineering di bytecode riferiti ad ISA virtuali: ad esempio il reverse engineering di programmi basati su \textbf{JVM} o \textbf{python byte code} dal momento che sono banali da reversare (ipotizzando, senza offuscamento).

Tutti gli strumenti di reverse engineering hanno un unico obiettivo: \textbf{recuperare le informazioni di alto livello} di un programma (ovvero tutte quelle informazioni che il compilatore rimuove durante la fase di compilazione). Le informazioni di alto livello sono importanti per avere una rappresentazione più o meno veritiera di quello che esegue il programma (sostanzialmente, il codice "sorgente"). Ignorando tutte le informazioni formali relative all'analisi statica, possiamo individuare diverse fasi di quello che avviene dopo che si importa il file all'interno di Ghidra, IDA o Binary Ninja.  

Nella prima parte di questo capitolo, utilizzeremo "strumenti di reverse engineering" per riferirci contemporaneamente a Ghidra, IDA o Binary Ninja perché sono sostanzialmente intercambiabili a livello di descrizione. Nella seconda parte invece introdurremo alcuni tips per identificare alcuni problemi dell'analisi statica e come poterli risolvere.

\section{Passi dell'analisi dei programmi}

Un qualsiasi programma dato in input agli strumenti di reverse engineering contengono principalmente due informazioni importanti: le istruzioni (cosa esegue la CPU) e i dati (su quali informazioni la CPU lavora). Queste informazioni contenute all'interno dei file binari sono posizionate con furbizia: il sistema operativo deve conoscere dove andare ad estrarre un certo tipo di informazioni. Quindi la soluzione più semplice è stata raggruppare una serie di informazioni "riassuntive" per dire al caricatore del sistema operativo dove andare per trovare, ad esempio, un tipo di dato.

Per strutturare al meglio il file, sono nati i formati eseguibili e principalmente sono di tre tipi: ELF (per Unix-like), PE (per Windows M\$) e Mach-O (per macOS). I tre strumenti di reverse engineering sono compatibili con tutti e tre i formati eseguibili e le principali architetture (intel x86-64): funzionano molto bene su binari compilati e non linguaggi interpretati. 

Capiamo meglio cosa succede quando importiamo il file:

\begin{itemize}
    \item \textbf{Lettura informazioni}: gli strumenti di reverse engineering devono sapere alcune informazioni sull'eseguibile come l'architettura target, come sono posizionate le informazioni (da quale indirizzo virtuale), individuazione della sezione relativa alle istruzioni e individuazione sezioni relative ai dati. Effettuano un parsing binario delle strutture e preparano una memoria virtuale dove sarà posizionato il programma come se fosse realmente eseguito da una CPU.
    \item \textbf{Disassemblaggio delle istruzioni}: capendo l'architettura "target" del file eseguibile, gli strumenti di analisi trasformano una serie di byte arbitrari in istruzioni "leggibili" dagli umani, facendo riferimento alla strutture delle istruzioni assembly dell'ISA.
    \item \textbf{Lifting}: gli strumenti di reverse engineering "astraggono"/"elevano l'informazione" applicando la fase di traduzione alle istruzioni disassemblate. Le istruzioni assembly dipendenti dall'architettura vengono trasformate in costrutti "universali" . Ogni strumento di reverse engineering adotta un linguaggio intermedio diverso (Ghidra utilizza \textit{SLEIGH}, Binary Ninja utilizza \textit{BLIL} e IDA \textit{IDA Microcode}), ma lo scopo è lo stesso: essere indipendenti dall'architettura.
    \item \textbf{Costruzione del grafo del controllo di flusso}: suddivisione delle istruzioni in blocchi elementari o basic block e successiva costruzione del grafo del controllo di flusso per ogni funzione. Il grafo del controllo di flusso è molto importante per poter applicare le analisi al punto successivo (data-flow, context-sensitive, context-insensitive). 
    \item \textbf{Applicazione di algoritmi di analisi}: svariati algoritmi sono applicati per poter inferire quante più informazioni di alto livello possibili. L'efficacia di questa operazione dipende principalmente dagli algoritmi implementati (diverse implementazioni per le tecniche di analisi) da parte degli strumenti di reverse engineering. Queste tecniche sono descritte in maggior dettaglio nella sottosezione, citiamo solo per esempio: la stack analysis, il loop recovery, il type inference. Il risultato finale è un codice pseudo-C che consente all'analista di capire molto bene come funziona il codice, ipotizzando di non avere offuscamenti.
\end{itemize}

Di seguito, scriviamo per ogni punto di analisi una descrizione per far capire meglio cosa si intende.

\subsection{Lettura informazioni}

La lettura delle informazioni consiste in un parsing di base che lo strumento di analisi effettua per poter applicare i successivi passi di analisi. Dobbiamo capire: il tipo di file, l'architettura, la composizione della memoria virtuale, come sono posizionate le sezioni, flag relative alla sezioni, entrypoint. Questa fase è principalmente legata alla sintassi e non c'è mai perdita di informazione. La stessa lettura delle informazioni viene effettuata da qualsiasi loader di un sistema operativo che deve caricare il file eseguibile in memoria.

\subsection{Disassemblaggio delle istruzioni}

\subsection{Lifting}

Ad esempio, l'istruzione \textbf{LEA} in x86\_64 e l'istruzione \textbf{LDR} in ARM rappresentano la stessa operazione semantica: il caricamento di un determinato indirizzo in un certo registro. Avrebbe senso sviluppare due algoritmi di analisi diversi per la stessa operazione semantica? No. Quindi sia \textbf{LEA} che \textbf{LDR} vengono tradotte con \textbf{LOAD} che identifica una operazione più generica. Questo ci consente di essere \textbf{INDIPENDENTE DALL'ARCHITETTURA!} 

\subsection{Costruzione del grafo del controllo di flusso}

\subsection{Analisi}

\chapter{Comandi terminale}
\section{Introduzione}
Durante una ctf potremmo trovarci di fronte ad alcune challenge in cui è necessario l'utilizzo di vari comandi della shell per recuperare la flag richiesta e quindi passare alla challenge successiva.
Di seguito vedremo alcuni comandi della shell per sistemi UNIX o macOS che possono tornare utili.

\section{Comandi di base}
Se si conosce un comando ma non si sa come utilizzarlo è bene consultare il manuale scrivendo sul terminale \textbf{man} $\langle command \rangle$. Se non è presente la pagina del manuale provare a specificare il flag \textbf{--help}. 

\section{Operazioni sulle directory}
\subsection{cd}
Per navigare attraverso il filesystem utilizziamo il comando \textbf{cd dir}.
\begin{itemize}
    \item \textbf{cd esempio} (ci spostiamo nella cartella \textit{esempio})
    \item \textbf{cd Dekstop/esempio} (ci spostiamo nella cartella \textit{esempio} identificata dal suo path)
    \item \textbf{cd ..} (ci permette di spostarci nella cartella superiore)
    \item \textbf{cd $\sim$} (ci spostiamo nella home directory)
    \item \textbf{cd /} (ci spostiamo nella root directory)
\end{itemize}
Per creare una cartella utilizziamo il comando \textbf{mk dir}, se invece vogliamo vedere la cartella corrente utlizziamo il comando \textbf{pwd}.

\subsection{ls}
Se vogliamo vedere i file all'interno di una cartella utilizziamo il comando \textbf{ls}.
\begin{itemize}
    \item \textbf{ls} (mostra i file nella cartella corrente)
    \item \textbf{ls Desktop/esempio} (mostra i file all'interno della cartella \textit{esempio} identificata dal path)
\end{itemize}
Tra le opzioni del comando \textbf{ls} possiamo trovare:
\begin{itemize}
    \item \textbf{-a} (mostra tutti i file, inclusi quelli nascosti)
    \item \textbf{-r} (inverte l'ordine della lista)
    \item \textbf{-t} (ordina in base all'ultimo modificato)
    \item \textbf{-S} (ordina per dimensione del file)
\end{itemize}

\section{Operazioni sui file}
\subsection{touch}
Per creare un file utilizzare il comando \textbf{touch file}.

\subsection{cat}
Il comando \textbf{cat} permette di concatenare file e stampare il loro contenuto sullo standard output.
\begin{itemize}
    \item \textbf{cat file} (stampa il contenuto del file, se vengono specificati più file li concatena e stampa il contenuto, e.g. cat file file2)
    \item \textbf{cat $<$ -file} (permette di stampare il contenuto di un file con il nome che inizia con un dash)
    \item \textbf{cat $"nome file con spazi"$} (permette di stampare il contenuto di un file che contiene spazi nel nome)
    \item \textbf{cat .file} (stampa il contenuto del file nascosto)
\end{itemize}

\subsection{cp, mv, rm, file}
\begin{itemize}
    \item \textbf{cp file file2} (copia file in file2)
    \item \textbf{mv file file2} (rinomino file in file2)
    \item \textbf{rm file} (elimino file)
        \begin{itemize}
            \item \textbf{rm -r} (rimuovo le directory e i loro contenuti)
            \item \textbf{rm -d} (rimuovo direcotry vuote)
        \end{itemize}
    \item \textbf{file file1} (ritorna il tipo di file1)
\end{itemize}

\subsection{head, tail}
\begin{itemize}
    \item \textbf{head file1} (ritorna le prime 10 linee di file1)
    \item \textbf{tail file1} (ritorna le ultime 10 linee di file1)
\end{itemize}

\subsection{strings}
Il comando \textbf{strings} stampa una sequenza di stringhe leggibili all'interno di un file.
\begin{itemize}
    \item \textbf{strings file}
    \begin{itemize}
        \item con il flag \textbf{-n number-of-lines} (specifichiamo la lunghezza minima delle stringhe)
        \item con il flag \textbf{-e encoding} (specifichiamo la codifica)
        \item con il flag \textbf{-w} (includiamo gli spazi bianchi)
        \item con il flag \textbf{-s} (il separatore per l'output)
    \end{itemize}
\end{itemize}

\section{Ricerca}
\subsection{sort, unique}
Il comando \textbf{sort file} permette di ordinare le linee all'interno di un file, il comando \textbf{unique -u} permette di mostrare le linee uniche non duplicate, questi due comandi possono essere comodi da usare in combinazione attraverso l'utilizzo di una pipe: \textbf{sort nomefile | unique -u}.

\subsection{grep}
Il comando \textbf{grep pattern files} permette di cercare un determinato pattern in ogni file, i pattern andrebbero specificati sempre compresi tra doppi apici.

\begin{itemize}
    \item \textbf{grep -i } (ricerca case-insensitive)
    \item \textbf{grep -r } (ricerca ricorsiva)
    \item \textbf{grep -v } (ricerca invertita)
    \item \textbf{grep -o } (mostra solo la parte di file che ha matchato il pattern)
\end{itemize}

\subsection{find}
Il comando \textbf{find} permette di cercare dei file all'interno del filesystem.

\begin{itemize}
    \item \textbf{find /percorso -name $"filename"$} (ricerca per nome)
    \item \textbf{find /percorso -name $"*.txt"$} (ricerca per estensione)
    \item \textbf{find /percorso -type f -size +1M} (ricerca per dimensione)
    \item \textbf{find /percorso -user utente -group gruppo} (ricerca per proprietario e gruppo)
    \item \textbf{find /percorso -mtime -7} (ricerca per data di modifica)
\end{itemize}

\section{Connessioni ssh o tcp}
Connessione ad una risorsa in ssh:

\begin{itemize}
    \item \textbf{ssh -p numero-porta utente@indirizzo-del-server}
\end{itemize}

Connessione tramite tcp:

\begin{itemize}
    \item \textbf{nc host port}
\end{itemize}

\section{Gestione dei processi}
\begin{itemize}
    \item \textbf{ps} (mostra uno snapshot dei processi)
    \item \textbf{top} (mostra i processi real-time)\item \textbf{}
    \item \textbf{kill pid} (termina un processo con il pid=pid)
    \item \textbf{pkill name} (termina un processo col nome=name)
    \item \textbf{killall name} (termina tutti i processi con il nome che inizia per name)
\end{itemize}

\end{document}
