\documentclass[oneside,a4paper,11pt]{book}
\usepackage[utf8]{inputenc}
\usepackage{svg}
\usepackage[italian]{babel}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage{titling}
\usepackage[margin=1in,footskip=0.25in]{geometry}
\usepackage{listings}
\usepackage[DIV=12,BCOR=2mm,headinclude=true,footinclude=false]{typearea}
\usepackage{color, colortbl,xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{tcolorbox}
\usepackage{chngcntr}
\usepackage{diagbox}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{parskip}
\usepackage{cancel}
\usepackage{forest}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{makecell}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{fancyhdr}
\fancypagestyle{plain}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}}
\pagestyle{fancy}
\fancyhf{}% Clear header/footer
\fancyhead[L]{\nouppercase\leftmark}
\fancyhead[R]{\thepage}
\usetikzlibrary{positioning,shapes.geometric,arrows.meta,matrix,automata,decorations.pathmorphing,patterns,decorations.pathreplacing,shapes.multipart,calc,snakes}
\usetikzlibrary{arrows.meta, backgrounds, chains, positioning, shapes.geometric, shapes.multipart}
\tcbuselibrary{skins}
\counterwithin{figure}{section}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% Configurazione per Python
\lstdefinestyle{pythonStyle}{
    backgroundcolor=\color{white},
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{mygreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{mygray},
    numbers=left,
    rulecolor=\color{black},
    showstringspaces=false,
    stringstyle=\color{mymauve},
    tabsize=4,
    language=Python
}

% Configurazione per Bash
\lstdefinestyle{bashStyle}{
    backgroundcolor=\color{white},
    basicstyle=\footnotesize\ttfamily,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{mygreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{mygray},
    numbers=left,
    rulecolor=\color{black},
    showstringspaces=false,
    stringstyle=\color{mymauve},
    tabsize=4,
    language=Bash
}
%Nuovi comandi
\newcommand\myeq{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\newcommand\prodG{\stackrel{\mathclap{\normalfont\mbox{\tiny{G}}}}{\Longrightarrow}}
%asmthm
\newlength{\marginlabelsep}\setlength{\marginlabelsep}{0.5em}
\newtheoremstyle{italicstyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\itshape} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\newtheoremstyle{normStyle} %% Name
  {} %% <- Space above (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {} %% <- Space below (empty = default = \topsep = 8.0pt plus 2.0pt minus 4.0pt)
  {\normalfont} %% <- Body font
  {} %% <- Indent amount (empty = no indent, \parindent = just that)
  {\bfseries} %% <- Thm head font
  {} %% <- Punctuation after thm head
  {1pt} %% <- Space after thm head (or " " or \newline) (default: 5pt plus 1pt minus 1pt)
  {\vtop to 0pt{\llap{\thmname{#1}\hskip\marginlabelsep}
                \llap{\thmnumber{#2}\hskip\marginlabelsep}}\thmnote{#3\\}%
  }
\theoremstyle{italicstyle}
\newtheorem{corollary}{Corollario}[section]
\newtheorem{notazione}{Notazione}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definizione}{Definizione}[section]
\newtheorem{nota}{Nota}[section]
\newtheorem{exercise}{Esercizio}[section]
\theoremstyle{normStyle}
\newtheorem{exmp}{Esempio}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{proposizione}{Proposizione}[section]
\tcbuselibrary{listings,skins}
\newtcblisting{mylisting}[2][]{
    arc=0pt, outer arc=0pt,
    listing only, 
    title=#2,
    #1,
    listing options= {escapechar=|}
}
\newcommand{\myboxedtext}[2][rectangle,draw]{%
    \tikz[baseline=-0.6ex] \node [#1]{#2};}%
%%======================================================================
\title{Capture the Flag Manual}
\author{
\textit{Alessio Gjergji}\\
\textit{Nicolò Piccoli} \\
\textit{Davide Rossignolo} \\
\textit{Author 4} \\
\textit{Author 5}}
\date{}
\begin{document}
\maketitle
\tableofcontents
\chapter{Software Security OlyCyber}
\section{Introduzione}
I numeri interi, in questo caso \texttt{int32}, possono essere rappresentati
in due maniera, Big-Endian (\textit{cifra significativa a sinistra}) e
Little-Endian (\textit{cifra significativa a destra}).
\section{Assembly \texttt{x86\_64}}
Ogni istruzione assembly ha degli operandi (\textit{registri}) e un'operazione.

La notazione per architetture intel è del tipo  $\langle \texttt{op} \rangle
\langle \texttt{destinazione} \rangle \langle \texttt{sorgente} \rangle$,
i registri hanno la seguente struttura:
$\texttt{AH},\texttt{AL} \rightarrow 8$ bit,
$\texttt{AX} \rightarrow 16$ bit,
$\texttt{EAX} \rightarrow 32$ bit,
$\texttt{RAX} \rightarrow 64$ bit.

Tra le operazioni di base che troviamo ci sono: 
\begin{itemize}
    \item $\texttt{MOV} \langle \texttt{dst}\rangle\langle \texttt{src}\rangle$
    \item $\texttt{PUSH} \langle \texttt{src}\rangle$ oppure $\texttt{POP}\langle \texttt{src}\rangle$
    \item $\texttt{ADD}$ oppure $\texttt{SUB} \langle \texttt{dst}\rangle\langle \texttt{src}\rangle$
    \item $\texttt{CALL} \langle \texttt{pc}\rangle$ oppure $\texttt{RET}$
\end{itemize}
Tra i salti condizionali invece abbiamo:
\begin{itemize}
    \item $\texttt{CMP} \langle \texttt{opn1}_1\rangle\langle \texttt{opn}_2\rangle$: confronta due valori e imposta delle flag
    \item $\texttt{J} \langle \texttt{condizione}\rangle\langle \texttt{pc}\rangle$: salta a PC se le flag soddisfano la condizione
\end{itemize}
\section{Buffer Overflow}
Consideriamo di aver dichiarato in \texttt{C} un'istruzione del tipo ``\texttt{char name[100]};",
cosa succede se l'utente ha un nome che supera i $100$ caratteri?.
Può succedere che con \texttt{scanf()} andiamo a scrivere caratteri oltre la fine di name,
andando a sovrascrivere la memoria che lo segue, generando quindi un \textit{buffer overflow}
che va a corrompere la memoria, ossia scriviamo dati in posizioni che il programmatore non
aveva previsto fossero modificate.

Se corrompiamo abbastanza bene la memoria possiamo addirittura prendere il controllo del
processo (\textit{arbitrary code execution}).
\subsection{Accessi out of bound}
Se abbiamo una \texttt{struct} che dichiara un \texttt{int a[2]} e un \texttt{int b[3]},
nel momento in cui scrivo in \texttt{a[2]} o in \texttt{b[0]} non cambia niente,
sono equivalenti.
\section{Reverse Engineering}
\subsection{Binary}
Gli eseguibili nativi sono file che contengono codice macchina eseguibile dal
processore, contengono anche informazioni usate dal sistema operativo per caricarlo
in memoria.

Il formato \texttt{.elf} è flessibile e serve a rappresentare i file binari,
in linux è usato per rappresentare eseguibili e librerie condivise, ad alto livello
invece risulta come un insieme di strutture che descrivono come caricare in memoria
i dati salvati nello stesso file.

Per analizzare file \texttt{ELF} abbiamo alcuni strumenti tra cui:
\begin{itemize}
    \item \texttt{readelf}: stampa le informazioni contenute nei file \texttt{.elf}
    \item \texttt{nm}: stampa tutti i simboli contenuti nel file \texttt{.elf}
    \item \texttt{objdump}: stampa le informazioni contenute nel file oggetto, è più specifico rispetto a readelf
    \item \texttt{lld}: stampa gli oggetti condivisi necessari all'esecuzione del programma
    \item \texttt{lief}: libreria python per analizzare e modificare file \texttt{.elf}.
\end{itemize}

\subsection{Memoria a basso livello}
Se vogliamo considerare un'astrazione della memoria troviamo vari livelli:
 \begin{itemize}
  \item \textbf{dati tipati}: byte interpretati
  \item linguaggi di programmazione
    \item textbf{memoria virtuale}: sequenza di byte indirizzabili, spazio indipendente per processo, solo alcune aree mappate(con la fisica)
    \item sistema operativo
    \item textbf{memoria fisica}: sequenza di byte indirizzabili
\end{itemize}

\subsection{Spazio virtuale linux user space}

\begin{itemize}
    \item \texttt{Text} $\rightarrow$ codice eseguibile
    \item \texttt{Data} $\rightarrow$ dati globali inizializzati
    \item \texttt{BSS} $\rightarrow$ dati globali azzerati
    \item \texttt{Heap} $\rightarrow$ allocazioni dinamiche
    \item \texttt{Librerie} $\rightarrow$ binari librerie dinamiche
    \item \texttt{Stack} $\rightarrow$ var locali, record di attivazione
\end{itemize}

\subsection{metodologie di base di reverse}
I più famosi tool per analisi statica sono
\textit{Ghidra, IDA, Binary Ninja,
Radare2} e servono per analizzare il codice binario. 

\begin{itemize}
\item \texttt{JADX}: reverse bytecode \texttt{java}
\item \texttt{dnSpy}, \texttt{ILSpy}: reverse bytecode \texttt{.NET}
\item \texttt{uncompyle6/unpyc}: reverse bytecode \texttt{python}
\item \texttt{Iuadec}: reverse bytecode \texttt{LUA}.
\end{itemize}
Tool per analisi dinamica:
\begin{itemize}
\item \texttt{gdb}: da usare con \texttt{GEF} o \texttt{PWNDBG}
\item \texttt{radare2} integra features comode per il reversing
\item rr timeless debugging
\item \texttt{frida}: inietta codice js in qualsiasi punto del programma
\item \texttt{ida}: debugger gui disponibile free.
\end{itemize}

\chapter{Software Security}
\section{Elf File}
È il file standard per gli eseguibili \texttt{UNIX}, \texttt{Elf} sta per
Executable and Linkable Format, è essenzialmente un file binario che
contiene varie informazioni tra cui:
\begin{itemize}
	\item \textbf{header}: descrive il contenuto del file per l'esecuzione
	\item \textbf{Pht (program header table)}: da informazioni su come si crea
    l'immagine del processo
	\item \textbf{Sequenza di sezioni}: contengono ciò che serve per il linking
	\item \textbf{Section header table}: descrizione delle sezioni precedenti 
\end{itemize}
Per Windows l'equivalente è PE, per Mac Mach-O.
\section{Memoria}
\subsection{Storage Size}
\begin{itemize}
    \item \texttt{WORD}: $2$ bytes;
    \item \texttt{DWORD}: $4$ bytes;
    \item \texttt{QWORD}: $8$ bytes;
\end{itemize}
La cifra più significativa è a sinistra, quella meno è a destra.
\subsection{Hexadecimal}
Si usa come forma compatta dei numeri binari, si va da $0$ a $9$ e da $A$ a $F$.
Ogni digit in hex rappresenta $4$ bits, quindi $2$ digit un bytes,
in \texttt{C} sono scritti come \texttt{0XFA1D}...

\subsection{Registri \texttt{x86\_32}}
Ha registri general purpose a 32 bit. Sono strutturati
nella seguente maniera: AH,AL 8 bit ciascuno, AX 16 bit,
\texttt{EAX} $32$ bit. EAX è storicamente usato come accumulatore,
\texttt{ECX} come counter, inoltre ci sono \texttt{ESP} (\textit{stack pointer}) e
EBP (\textit{base pointer}). Se passiamo a \texttt{x86\_64} 
si aggiungono i
registri a 64 bit che si nominano del tipo: \texttt{RAX}.

\subsection{x86 Memory Management}
La memoria è semplicemente una sequenza di bytes,
ognuno con un indirizzo unico. I compilatori potrebbero
introdurre padding per cambiare l'ordine dei dati per ottimizzare,
per questo motivo ci torna comodo vederla come una matrice di tot
righe con n bytes (n=processor word), se sono a 64 bit n=8. Un
indirizzo è una locazione in memoria, un \textbf{puntatore} è un
oggetto che mantiene un indirizzo. I bytes possono essere ordinati
in memoria in due maniere:
\begin{itemize}
\item \textbf{Big-Endian}: il byte meno significativo ha indirizzo più alto
\item \textbf{Little-Endian}: il byte meno significativo ha indirizzo più basso
\end{itemize}

\section{Intel x86 Instruction Set}
La notazione per architetture Intel è del tipo $\langle op\rangle \langle
destinazione\rangle\langle sorgente\rangle$. Vediamo ora alcune istruzioni:
\begin{itemize}
\item \texttt{mov}: muove dati da un src a un registro dst
\item \texttt{push}: mette l'operando sullo stack
\item \texttt{pop}: rimuove l'operando dallo stack
\item \texttt{lea}: carica ciò che c'è all'indirizzo [] in dst
\item \texttt{add}: fa la somma e salva in op1
\item \texttt{sub}: fa la differenza e salva in op1
\item \texttt{inc}: incrementa di 1
\item \texttt{and/or/xor}: fa l'operazione e salva in op1
\item \texttt{jump}: salto non condizionale a label
\item \texttt{cmp}: compara contenuto di op1 con op2
\item \texttt{je/jne/jz/jg/jge/jl/jle}: in base a cmp fa salto condizionale 
\item \texttt{call}: usato per chiamare funzioni
\item \texttt{ret}: implementa il ritorno da funzione
\end{itemize}

Per quanto riguarda lo stack, questo è formato da degli stack frames, uno per ogni funzione chiamata. Il \textbf{stack pointer} punta all'ultimo elemento nello stack (il primo inserito). Per quanto riguarda ogni singolo frame, abbiamo che il \textbf{base pointer (frame pointer)} punta all'indirizzo dal quale partono le variabili locali.

\section{Debugging con GDB}
Posso usare gdb in varie maniere:
\begin{itemize}
\item gdb \textgreater program \textless
\item gdb \textgreater program \textless \textgreater pid \textless 
\item gdb  -p \textgreater pid \textless
\end{itemize}

\subsection{Comandi di GDB}
\begin{itemize}
\item run: fa partire il programma in gdb
\item set args: imposta gli argomenti del programma
\item show args: mostra gli argomenti del programma
\item help: comandi disponibili
\item break: mette breakpoint alla prossima istruzione
\item break location: mette un breakpoint alla locazione location(preceduta da *)
\item break [location] if \textgreater condition \textless: mette un breakpoint data una condizione
\item continue(c): va al prossimo breakpoint(se esiste)
\item nexti(ni): esegue solo un'istruzione
\item frame [\textgreater selection \textless]: stampa una descrizione dello stack frame selezionato
\item info frame [\textgreater selection \textless]: stampa una descrizione più informativa rispetto a frame
\item disas: disassembla una funzione
\item print(p): stampa il contenuto di un indirizzo o registro(*0x092a3e or \$eax)  
\item x: non ho ben capito
\item call: chiama una funzione 
\item set: modifica il valore di una locazione di memoria o di un registro

\end{itemize}


\chapter{Comandi terminale}
\section{Introduzione}
Durante una ctf potremmo trovarci di fronte ad alcune challenge in cui è necessario l'utilizzo di vari comandi della shell per recuperare la flag richiesta e quindi passare alla challenge successiva.
Di seguito vedremo alcuni comandi della shell per sistemi UNIX o macOS che possono tornare utili.

\section{Comandi di base}
Se si conosce un comando ma non si sa come utilizzarlo è bene consultare il manuale scrivendo sul terminale \textbf{man} $\langle command \rangle$. Se non è presente la pagina del manuale provare a specificare il flag \textbf{--help}. 

\section{Operazioni sulle directory}
\subsection{cd}
Per navigare attraverso il filesystem utilizziamo il comando \textbf{cd dir}.
\begin{itemize}
    \item \textbf{cd esempio} (ci spostiamo nella cartella \textit{esempio})
    \item \textbf{cd Dekstop/esempio} (ci spostiamo nella cartella \textit{esempio} identificata dal suo path)
    \item \textbf{cd ..} (ci permette di spostarci nella cartella superiore)
    \item \textbf{cd $\sim$} (ci spostiamo nella home directory)
    \item \textbf{cd /} (ci spostiamo nella root directory)
\end{itemize}
Per creare una cartella utilizziamo il comando \textbf{mk dir}, se invece vogliamo vedere la cartella corrente utlizziamo il comando \textbf{pwd}.

\subsection{ls}
Se vogliamo vedere i file all'interno di una cartella utilizziamo il comando \textbf{ls}.
\begin{itemize}
    \item \textbf{ls} (mostra i file nella cartella corrente)
    \item \textbf{ls Desktop/esempio} (mostra i file all'interno della cartella \textit{esempio} identificata dal path)
\end{itemize}
Tra le opzioni del comando \textbf{ls} possiamo trovare:
\begin{itemize}
    \item \textbf{-a} (mostra tutti i file, inclusi quelli nascosti)
    \item \textbf{-r} (inverte l'ordine della lista)
    \item \textbf{-t} (ordina in base all'ultimo modificato)
    \item \textbf{-S} (ordina per dimensione del file)
\end{itemize}

\section{Operazioni sui file}
\subsection{touch}
Per creare un file utilizzare il comando \textbf{touch file}.

\subsection{cat}
Il comando \textbf{cat} permette di concatenare file e stampare il loro contenuto sullo standard output.
\begin{itemize}
    \item \textbf{cat file} (stampa il contenuto del file, se vengono specificati più file li concatena e stampa il contenuto, e.g. cat file file2)
    \item \textbf{cat $<$ -file} (permette di stampare il contenuto di un file con il nome che inizia con un dash)
    \item \textbf{cat $"nome file con spazi"$} (permette di stampare il contenuto di un file che contiene spazi nel nome)
    \item \textbf{cat .file} (stampa il contenuto del file nascosto)
\end{itemize}

\subsection{cp, mv, rm, file}
\begin{itemize}
    \item \textbf{cp file file2} (copia file in file2)
    \item \textbf{mv file file2} (rinomino file in file2)
    \item \textbf{rm file} (elimino file)
        \begin{itemize}
            \item \textbf{rm -r} (rimuovo le directory e i loro contenuti)
            \item \textbf{rm -d} (rimuovo direcotry vuote)
        \end{itemize}
    \item \textbf{file file1} (ritorna il tipo di file1)
\end{itemize}

\subsection{head, tail}
\begin{itemize}
    \item \textbf{head file1} (ritorna le prime 10 linee di file1)
    \item \textbf{tail file1} (ritorna le ultime 10 linee di file1)
\end{itemize}

\subsection{strings}
Il comando \textbf{strings} stampa una sequenza di stringhe leggibili all'interno di un file.
\begin{itemize}
    \item \textbf{strings file}
    \begin{itemize}
        \item con il flag \textbf{-n number-of-lines} (specifichiamo la lunghezza minima delle stringhe)
        \item con il flag \textbf{-e encoding} (specifichiamo la codifica)
        \item con il flag \textbf{-w} (includiamo gli spazi bianchi)
        \item con il flag \textbf{-s} (il separatore per l'output)
    \end{itemize}
\end{itemize}

\section{Ricerca}
\subsection{sort, unique}
Il comando \textbf{sort file} permette di ordinare le linee all'interno di un file, il comando \textbf{unique -u} permette di mostrare le linee uniche non duplicate, questi due comandi possono essere comodi da usare in combinazione attraverso l'utilizzo di una pipe: \textbf{sort nomefile | unique -u}.

\subsection{grep}
Il comando \textbf{grep pattern files} permette di cercare un determinato pattern in ogni file, i pattern andrebbero specificati sempre compresi tra doppi apici.

\begin{itemize}
    \item \textbf{grep -i } (ricerca case-insensitive)
    \item \textbf{grep -r } (ricerca ricorsiva)
    \item \textbf{grep -v } (ricerca invertita)
    \item \textbf{grep -o } (mostra solo la parte di file che ha matchato il pattern)
\end{itemize}

\subsection{find}
Il comando \textbf{find} permette di cercare dei file all'interno del filesystem.

\begin{itemize}
    \item \textbf{find /percorso -name $"filename"$} (ricerca per nome)
    \item \textbf{find /percorso -name $"*.txt"$} (ricerca per estensione)
    \item \textbf{find /percorso -type f -size +1M} (ricerca per dimensione)
    \item \textbf{find /percorso -user utente -group gruppo} (ricerca per proprietario e gruppo)
    \item \textbf{find /percorso -mtime -7} (ricerca per data di modifica)
\end{itemize}

\section{Connessioni ssh o tcp}
Connessione ad una risorsa in ssh:

\begin{itemize}
    \item \textbf{ssh -p numero-porta utente@indirizzo-del-server}
\end{itemize}

Connessione tramite tcp:

\begin{itemize}
    \item \textbf{nc host port}
\end{itemize}

\section{Gestione dei processi}
\begin{itemize}
    \item \textbf{ps} (mostra uno snapshot dei processi)
    \item \textbf{top} (mostra i processi real-time)\item \textbf{}
    \item \textbf{kill pid} (termina un processo con il pid=pid)
    \item \textbf{pkill name} (termina un processo col nome=name)
    \item \textbf{killall name} (termina tutti i processi con il nome che inizia per name)
\end{itemize}

\input{cryptography.tex}
\end{document}
